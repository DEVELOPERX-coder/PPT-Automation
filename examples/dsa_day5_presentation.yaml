# DSA in 45 - Day 5 Presentation

variables:
  title_color: [240, 240, 240] # Light gray
  text_color: [220, 220, 220] # Light gray
  accent_color: [0, 191, 255] # Deep sky blue
  background_color: [30, 30, 30] # Dark gray/nearly black
  code_background: [45, 45, 45] # Slightly lighter dark gray
  highlight_color: [255, 140, 0] # Orange for emphasis

settings:
  style:
    title_font: "Arial"
    title_size: 40
    body_font: "Arial"
    body_size: 20
    theme_color: [0, 191, 255] # Deep sky blue

slides:
  # Title slide
  - type: title_slide
    title: "üöÄ DAY 5: Vectors & STL Containers"
    subtitle: "Why Reinvent the Wheel? #DSAin45"

  # Introduction
  - type: title_and_content
    title: "Introduction to STL Containers"
    content:
      - "C++'s STL provides ready-to-use container classes"
      - "Pre-made, well-tested, optimized implementations"
      - "Saves you from writing your own data structures"
      - '"The STL is like IKEA furniture for programmers: pre-made, well-tested, and only occasionally missing a critical piece."'

  # STL Container Family - Section Header
  - type: section
    title: "The STL Container Family"

  # Sequence Containers
  - type: title_and_content
    title: "1. Sequence Containers"
    content:
      - "std::vector - Dynamic array (our focus today)"
      - "std::array - Fixed-size array"
      - "std::list - Doubly-linked list"
      - "std::forward_list - Singly-linked list"
      - "std::deque - Double-ended queue"

  # Associative Containers
  - type: title_and_content
    title: "2. Associative Containers"
    content:
      - "std::set - Collection of unique keys"
      - "std::map - Collection of key-value pairs"
      - "std::multiset - Set allowing duplicate keys"
      - "std::multimap - Map allowing duplicate keys"

  # Unordered Containers
  - type: title_and_content
    title: "3. Unordered Containers"
    content:
      - "std::unordered_set - Hash table with unique keys"
      - "std::unordered_map - Hash table with key-value pairs"
      - "std::unordered_multiset - Hash table allowing duplicate keys"
      - "std::unordered_multimap - Hash table allowing duplicate key-value pairs"

  # Container Adapters
  - type: title_and_content
    title: "4. Container Adapters"
    content:
      - "std::stack - LIFO data structure"
      - "std::queue - FIFO data structure"
      - "std::priority_queue - Heap-based priority queue"

  # Deep Dive: std::vector - Section Header
  - type: section
    title: "üîé Deep Dive: std::vector"

  # Vector Core Characteristics
  - type: title_and_content
    title: "Vector Core Characteristics"
    content:
      - "Dynamic array that resizes automatically"
      - "Contiguous memory storage"
      - "Random access in O(1) time"
      - "Fast insertion/deletion at the end O(1) amortized"
      - "Slower insertion/deletion in the middle or beginning O(n)"
      - "The Swiss Army knife of data structures‚Äînot always perfect, but rarely a disaster"

  # Vector Initialization
  - type: title_and_content
    title: "Creating and Initializing Vectors"
    content: |
      ```cpp
      // Basic initialization
      std::vector<int> numbers;              // Empty vector
      std::vector<int> numbers(10);          // Vector with 10 zeroes
      std::vector<int> numbers(10, 5);       // Vector with 10 fives
      std::vector<int> copy(numbers);        // Copy of another vector

      // Initializer list
      std::vector<int> numbers = {1, 2, 3, 4, 5};

      // 2D vectors
      std::vector<std::vector<int>> grid(3, std::vector<int>(4, 0));  // 3√ó4 grid of zeroes
      ```

  # Vector Operations
  - type: title_and_content
    title: "Essential Vector Operations"
    content: |
      ```cpp
      // Adding elements
      numbers.push_back(6);            // Add to end
      numbers.insert(numbers.begin(), 0);  // Insert at beginning

      // Accessing elements
      int first = numbers[0];          // No bounds checking
      int last = numbers.at(numbers.size() - 1);  // With bounds checking

      // Removing elements
      numbers.pop_back();              // Remove last element
      numbers.erase(numbers.begin());  // Remove first element
      numbers.clear();                 // Remove all elements
      ```

  # Vector Memory Management
  - type: title_and_content
    title: "Vector Memory Management"
    content:
      - "Size: Number of elements currently in the vector"
      - "Capacity: Amount of allocated space"
      - "When size reaches capacity, vector allocates new (larger) memory"
      - "reserve(): Pre-allocates memory without changing size"
      - "shrink_to_fit(): Reduces capacity to match size"
      - "std::move avoids deep copies when transferring ownership"

  # Other Containers - Section Header
  - type: section
    title: "üß© Other Essential STL Containers"

  # std::list
  - type: title_and_content
    title: "std::list - Doubly Linked List"
    content:
      - "When to use it:"
      - "  ‚Ä¢ Frequent insertions/deletions anywhere in the container"
      - "  ‚Ä¢ No need for random access"
      - "  ‚Ä¢ Size changes frequently"
      - ""
      - "A linked list is like a treasure hunt‚Äîto find something, you must follow the entire chain of clues, but adding a new clue anywhere is easy."

  # std::deque
  - type: title_and_content
    title: "std::deque - Double-Ended Queue"
    content:
      - "When to use it:"
      - "  ‚Ä¢ Need efficient insertion/deletion at both ends"
      - "  ‚Ä¢ Still need random access (though slightly slower than vector)"
      - ""
      - "A deque is the line at a trendy nightclub‚Äîpeople can join or leave from either end, but nobody's allowed to cut into the middle."

  # std::set
  - type: title_and_content
    title: "std::set - Ordered Unique Elements"
    content:
      - "When to use it:"
      - "  ‚Ä¢ Need to maintain sorted elements"
      - "  ‚Ä¢ Need fast lookup (O(log n))"
      - "  ‚Ä¢ Elements must be unique"
      - ""
      - "A set is like a very exclusive club‚Äîeverything inside is arranged in perfect order, duplicates are turned away at the door, and finding a member is surprisingly efficient."

  # std::map
  - type: title_and_content
    title: "std::map - Key-Value Pairs"
    content:
      - "When to use it:"
      - "  ‚Ä¢ Need key-value associations"
      - "  ‚Ä¢ Need keys sorted"
      - "  ‚Ä¢ Need fast key-based lookups"
      - ""
      - "A map is like a well-organized library‚Äîevery value (book) has a unique key (catalog number), everything's in order, and finding what you want is quick if you know its name."

  # std::unordered_map
  - type: title_and_content
    title: "std::unordered_map - Hash Table"
    content:
      - "When to use it:"
      - "  ‚Ä¢ Need fastest possible lookups O(1) average"
      - "  ‚Ä¢ Don't care about element ordering"
      - "  ‚Ä¢ Have a good hash function for your key type"
      - ""
      - "An unordered_map is like a chaotic office desk where everything seems randomly placed, but you can instantly find any document you ask for."

  # Performance Comparison - Section Header
  - type: section
    title: "‚öñÔ∏è STL Container Performance Comparison"

  # Performance Table
  - type: title_only
    title: "Performance Comparison"
    elements:
      - type: text_box
        left: 0.5
        top: 1.5
        width: 9
        height: 4
        text: |
          | Operation               | vector | list   | deque  | set/map  | unordered_map |
          | ----------------------- | ------ | ------ | ------ | -------- | ------------- |
          | Random Access           | O(1)   | O(n)   | O(1)   | O(log n) | O(1) avg      |
          | Insert/Remove at Start  | O(n)   | O(1)   | O(1)   | O(log n) | O(1) avg      |
          | Insert/Remove at End    | O(1)*  | O(1)   | O(1)   | O(log n) | O(1) avg      |
          | Insert/Remove in Middle | O(n)   | O(1)** | O(n)   | O(log n) | O(1) avg      |
          | Search                  | O(n)   | O(n)   | O(n)   | O(log n) | O(1) avg      |
          | Memory Overhead         | Low    | High   | Medium | Medium   | High          |

          * Amortized constant time due to occasional resizing
          ** If iterator position is known, otherwise O(n) to find the position
        font: "Consolas"
        size: 16

  # STL Container Adapter - Section Header
  - type: section
    title: "üß† STL Container Adapters"

  # Stack
  - type: title_and_content
    title: "The Stack (LIFO)"
    content: |
      ```cpp
      #include <stack>

      std::stack<int> s;

      // Basic operations
      s.push(10);   // Add to top
      s.push(20);

      int top = s.top();  // Access top element (20)
      s.pop();            // Remove top element

      bool empty = s.empty();  // Check if empty
      size_t size = s.size();  // Get size
      ```

  # STL Algorithms - Section Header
  - type: section
    title: "üèπ STL Algorithms: Containers' Best Friends"

  # Algorithms Examples
  - type: title_and_content
    title: "Essential STL Algorithms"
    content: |
      ```cpp
      // Find elements
      auto it = std::find(vec.begin(), vec.end(), value);

      // Sort container
      std::sort(vec.begin(), vec.end());

      // Binary search (on sorted data)
      bool found = std::binary_search(vec.begin(), vec.end(), value);

      // Reverse container
      std::reverse(vec.begin(), vec.end());

      // Find min/max elements
      auto min = std::min_element(vec.begin(), vec.end());
      auto max = std::max_element(vec.begin(), vec.end());
      ```

  # Container Selection - Section Header
  - type: section
    title: "üìã STL Container Selection Guide"

  # Selection Guide
  - type: title_only
    title: "Container Selection Guide"
    elements:
      - type: text_box
        left: 0.5
        top: 1.5
        width: 9
        height: 4
        text: |
          | If you need...                                | Use...         |
          | --------------------------------------------- | -------------- |
          | Fast random access & cache-friendly iteration | vector         |
          | Frequent insertion/removal at both ends       | deque          |
          | Frequent insertion/removal at any position    | list           |
          | Automatically sorted elements                 | set            |
          | Key-value lookups with sorted traversal       | map            |
          | Fastest possible lookups with no ordering     | unordered_map  |
          | LIFO (stack) behavior                         | stack          |
          | FIFO (queue) behavior                         | queue          |
          | Heap behavior (highest priority first)        | priority_queue |
        font: "Consolas"
        size: 16

  # Common Pitfalls - Section Header
  - type: section
    title: "üî• Common STL Pitfalls and Best Practices"

  # Pitfalls
  - type: title_and_content
    title: "Three Major Pitfalls"
    content:
      - "1. Iterator Invalidation:"
      - "   When container modifications invalidate existing iterators"
      - ""
      - "2. Inefficient Vector Resizing:"
      - "   Not using reserve() when you know the size in advance"
      - ""
      - "3. Using the Wrong Container:"
      - "   Performance suffers when container choice doesn't match usage pattern"

  # Practice Problem
  - type: title_and_content
    title: "üß© Practice Problem"
    content:
      - "Find the first non-repeating character in a string"
      - ""
      - "Examples:"
      - '‚Ä¢ Input: "leetcode" ‚Üí Output: ''l'''
      - '‚Ä¢ Input: "loveleetcode" ‚Üí Output: ''v'''
      - ""
      - "Think about:"
      - "1. Which container(s) would be most appropriate?"
      - "2. How can you maintain the original order?"
      - "3. What's the most efficient approach?"

  # LeetCode Practice - Section Header
  - type: section
    title: "üìö LeetCode Practice Problems"

  # LeetCode Easy
  - type: title_and_content
    title: "LeetCode Practice - Easy"
    content:
      - "#1: Two Sum (Hash Map)"
      - "#20: Valid Parentheses (Stack)"
      - "#217: Contains Duplicate (Set/Hash Set)"
      - "#706: Design HashMap (Implement your own)"

  # LeetCode Medium & Hard
  - type: title_and_content
    title: "LeetCode Practice - Medium & Hard"
    content:
      - "Medium:"
      - "‚Ä¢ #49: Group Anagrams (Hash Map)"
      - "‚Ä¢ #380: Insert Delete GetRandom O(1) (Vector + Hash Map)"
      - "‚Ä¢ #146: LRU Cache (List + Hash Map)"
      - "‚Ä¢ #347: Top K Frequent Elements (Hash Map + Heap)"
      - ""
      - "Hard:"
      - "‚Ä¢ #460: LFU Cache (Multiple Maps + Lists)"

  # Tomorrow's Preview
  - type: title_slide
    title: "üîÆ Coming Tomorrow"
    subtitle: "Linked Lists: The Data Structure That Causes Both Relief and Hair Loss"
